Am declarat matricea board[BOARD_SIZE][BOARD_SIZE], care reprezinta tabla de joc, ca variabila globala(abatere permisa).

Functia value_of_the_word() calculeaza scorul cuvantului primit ca parametru, fara a lua in considerare conditia de bonus. Pentru a tine informatiile pentru scorurile fiecarei litere, am initializat un vector cu toate valorile puse in ordine alfabetica. Pentru a afla la ce index in vector se afla scorul unei litere, am substras valoarea ‘A’ din litera cautata. Variabila wl retine lungimea cuvantului (conversie pentru ca strlen(word) returneaza size_t  si nu poate fi comparat cu int i).

Functia bonus score()  primeste ca parametrii coordonatele, si pointeri la cuvantul ales de jucator si substringurile pentru verificarea conditiei de bonus si returneaza numarul cu care trebuie inmultit scorul initial dupa aplicarea conditiilor de bonus. Variabila se_aplica_bonus1 verifica conditia de bonus pentru substringul 1(substringul sa se afle in cuvant), iar se_aplica_bonus2 verifica conditia de bonus pentru substringul 2(substringul se afla la sfarsitul cuvantului).
Variabilele numar_aparitii_1 si numar_aparitii_2 returneaza numarul de casute de 1 si de 2 cu care se suprapune un cuvant in tabla de bonusuri(se numara doar daca este indeplinita conditia de bonus specifica).

Functia check_already_played() verifica daca un anumit index se afla intr-un vector. Se foloseste la task4, 5, 6.   Functia primeste ca parametru un index din vecotrul words[][NUM_WORDS] si un pointer la un vector care retine toti indecsii corespunzatori cuvintelor folosite de jucatori. Se verifica daca un cuvant de la indexul word_index a fost deja folosit.

Functia put_word_on_board() primeste ca parametrii coordonatele X, Y si D si un pointer la cuvantul ales de jucator si il afiseaza pe tabla de joc, in functie de D. Daca D = 0, cuvantul este pe orizontala. Deci prima litera va fi la [X][Y+0] urmand sa incrementam Y-ul cu valoarea lui l. X(randul) ramane neschimbat. Daca D = 1, cuvantul este pe verticala. Deci prima litera va fi la [X+0][Y] urmand sa incrementam X-ul cu valoarea lui l. Y(coloana) ramane neschimbata.

Functia get_next_word() are ca parametrii un pointer la un cuvant din vectorul words[][NUM_WORDS] care nu a fost deja ales de jucator si coordonatele acestuia (initial, sunt -1, -1, -1, fara corespondent pe tabla.). Se cauta pe tabla de joc incepand din coltul din stanga sus prima litera a cuvantului. Daca a fost gasita, se verifica daca acel cuvant se incadreaza pe orizontala sau pe verticala pe tabla de joc, iar coordonatele acestuia sunt date de cele ale primei litere gasite. Daca nu se incadreaza sau nu se gaseste prima litera pe tabla de joc, coordonatele raman (-1, -1, -1).

Functia get_optimum_word() selecteaza cuvantul optim, cu scorul cel mai mare, care merge pus pe tabla.(se foloseste la task 5 si 6). Variabila optim_word va retine: rand, coloana, directie, index_cuvant din words[], scor pentru cuvantul cu scorul cel mai mare. Pentru fiecare cuvant din vectorul words, se verifica daca a mai fost folosit, daca prima sa litera se gaseste deja pe tabla Daca se gaseste, se initializeaza coordonatele sale cu -1, se verifica daca merge scris pe orizontala sau verticala, se obtin coordonatele sale (corespunzatoare unei pozitii pe tabla) si scorul cu aplicarea bonusului. Daca scorul este maxim(cel mai mare scor obtinut pentru un cuvant) acela este cuvantul cautat (se stocheaza in optim_word scorul, coordonatele si indexul sau).Daca se obtin scorurul maxim  in mai multe locuri, se alege pozitia cu linia cea mai mica, daca liniile sunt egale, se alege cea care are cea mai mica coloana.

Functia task0() initializeaza tabla de joc cu ',' si o afiseaza cu ajutorul functiei  print_board().

In functia task1(), mai intai se initializeza tabla de joc, apoi se citeste un numar, care reprezinta numarul de linii ce urmeaza sa fie citite. Pentru fiecare linie citita, variabila *input[4] memoreaza indicele pe verticala (input[0]), indicele pe orizontal (input[1]), directia (input[2]), si cuvantul introdus (input[3]). Pentru ca functia fgets citeste si caracterul '\n', l-am inlocuit cu null terminator. ('/0'). Pentru fiecare cuvant, punem pe tabla de joc cuvantul la coordonatele X, Y, D.

In functia task2() se citeste input-ul la fel ca in task1().Daca indexul liniei este par, joaca primul user, altfel, joaca al doilea user. Pentru fiecare cuvant se calculeaza scorul fara conditia de bonus si se adauga la scorul user-ului corespunzator. La final, sunt afisate scorurile celor doi jucatori conform standardului output-ului.

Functia task3() citeste 2 substringuri, primul pentru verificarea conditiei de bonus pentru casutele mascate cu 1, iar al doilea pentru casutele marcate cu 2. Mai departe, are input-ul identic cu ultimele 2 functii. In functie de paritatea indexului liniei(userul care joaca), se calculeaza scorul pentru fiecare cuvant. Acesta rezulta din scorul fara bonus, inmultit cu numarul rezultat din indeplinirea conditiei  de bonus.  La final, sunt afisate scorurile celor doi jucatori.

Functia task4() are acelasi format de input ca la task3. Vectorul used_words retine pozitiile fiecarui cuvant jucat de useri din vectorul de cuvinte words[][NUM_WORDS] (daca nu apare, o sa fie -1). Se verifica pe rand daca un cuvant din vecotrul words a fost deja folosit de vreun jucator. Pentru primul cuvant nefolosit, se verifica daca prima sa litera se afla deja  pe tabla si se incadreaza in dimensiunile tablei, prin functia get_next_word. Aceasta returneaza coordonatele cuvantului sau (-1, -1, -1) in caz contrar. Daca se obtin niste coordonate care au corespondent pe tabla de joc, acel cuvant este cel cautat si se adauga pe tabla de joc. In caz contrar, se continua cautarea.

Functia task5() citeste input-ul la fel ca la task3 si 4, vectorul used_words retine pozitiile fiecarui cuvant jucat de useri in vectorul de cuvinte words[][NUM_WORDS]. Fiecare cuvant jucat se afiseaza pe tabla si se calculeaza scorul pentru fiecare jucator, tinand seama de bonus. Se obtin coordonatele, scorul si indexul cuvantul din words care aduce scorul maxim, cu ajutorul funcctiei get_optimum_word(). Daca scorul rezultat in urma alegerii de catre Player2 a cuvantului returnat de functie va produce un scor mai mare *sau* egal cu scorul Player-ului 1, se afiseza pe tabla. Daca nu, se va afisa "Fail!".

Functia task6() primeste la input doar cuvinte pentru Player1 (input-ul este identic celor de la ultimele 3 task-uri). Se initializeaza vectorul used_words[] cu -1. Se citeste cate un cuvant pentru Player1, apoi se genereaza cel optim pentru Player2. Daca Player 1 a folosit un cuvant din vectorul words, se salveaza indexul sau in used_words[]. Cuvintele se pun pe tabla de joc, se calculeaza scorul pentru fiecare jucator. Se adauga indexul cuvantului optim obtinut de Player2 in vectorul used_words[].(pentru a fi considerat deja folosit la urmatoarele apeluri). La final,se afiseaza tabla, si  in functie de scorul obtinut, se afiseaza  care jucator a castigat.  

 Functia main apeleaza functiile pentru task-ul corespunzator in functie de primului input primit (0-5 pentru tema, 6 pentru bonus), iar restul de date se citesc asa cum este descris pentru fiecare cerinta in parte.

